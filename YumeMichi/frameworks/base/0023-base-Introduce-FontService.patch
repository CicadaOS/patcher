From f3e4c13e84bc713f89ba4841c763b310ea44c87b Mon Sep 17 00:00:00 2001
From: bigrushdog <randall.rushing@gmail.com>
Date: Tue, 27 Feb 2018 15:09:48 -0800
Subject: [PATCH 23/37] base: Introduce FontService

In addition to shipping with a series of fonts, this service
also supports user apps that provide fonts. To create a font
provider app, put the following bool into your package resources

<bool name="custom_rom_font_provider">true</bool>

Then put the font zips into

/res/assets/fonts/font1.zip... font2.zip...

At a later time, other font sources may be supported, but this
is not certain.

Change-Id: Ie3b4e3e740956f34b0ffb45c4632c2f62f26f48a
---
 Android.mk                                    |   1 +
 core/java/android/content/FontInfo.aidl       |  19 +
 core/java/android/content/FontInfo.java       | 120 +++
 core/java/android/content/IFontService.aidl   |  40 +
 core/java/android/provider/Settings.java      |  16 +
 core/res/AndroidManifest.xml                  |   7 +
 core/res/res/values/custom_arrays.xml         |  25 +
 core/res/res/values/custom_strings.xml        |  26 +
 core/res/res/values/custom_symbols.xml        |  23 +
 .../java/com/android/server/FontService.java  | 689 ++++++++++++++++++
 .../java/com/android/server/SystemServer.java |   7 +
 11 files changed, 973 insertions(+)
 create mode 100644 core/java/android/content/FontInfo.aidl
 create mode 100644 core/java/android/content/FontInfo.java
 create mode 100644 core/java/android/content/IFontService.aidl
 create mode 100644 core/res/res/values/custom_arrays.xml
 create mode 100644 core/res/res/values/custom_strings.xml
 create mode 100644 core/res/res/values/custom_symbols.xml
 create mode 100644 services/core/java/com/android/server/FontService.java

diff --git a/Android.mk b/Android.mk
index 73dc9dced8f..15a23e883e9 100644
--- a/Android.mk
+++ b/Android.mk
@@ -149,6 +149,7 @@ LOCAL_SRC_FILES += \
 	core/java/android/bluetooth/le/IScannerCallback.aidl \
 	core/java/android/content/IClipboard.aidl \
 	core/java/android/content/IContentService.aidl \
+	core/java/android/content/IFontService.aidl \
 	core/java/android/content/IIntentReceiver.aidl \
 	core/java/android/content/IIntentSender.aidl \
 	core/java/android/content/IOnPrimaryClipChangedListener.aidl \
diff --git a/core/java/android/content/FontInfo.aidl b/core/java/android/content/FontInfo.aidl
new file mode 100644
index 00000000000..7315d56867f
--- /dev/null
+++ b/core/java/android/content/FontInfo.aidl
@@ -0,0 +1,19 @@
+/**
+ * Copyright (c) 2010, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content;
+
+parcelable FontInfo;
diff --git a/core/java/android/content/FontInfo.java b/core/java/android/content/FontInfo.java
new file mode 100644
index 00000000000..f7c9c526676
--- /dev/null
+++ b/core/java/android/content/FontInfo.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2018 The Dirty Unicorns Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.text.TextUtils;
+
+public class FontInfo implements Parcelable, Comparable<FontInfo> {
+    public static final String DEFAULT_FONT_PACKAGE = "android";
+    public static final String DEFAULT_FONT_NAME = "Roboto";
+    public static final String DEFAULT_FONT_PATH = "/system/fonts/Roboto-Regular.ttf";
+
+    private static final FontInfo sDefaultInfo = new FontInfo(DEFAULT_FONT_PACKAGE, DEFAULT_FONT_NAME,
+            DEFAULT_FONT_PATH);
+
+    public String packageName;
+    public String fontName;
+    public String previewPath;
+
+    public static FontInfo getDefaultFontInfo() {
+        return new FontInfo(sDefaultInfo);
+    }
+
+    public static final Parcelable.Creator<FontInfo> CREATOR = new Parcelable.Creator<FontInfo>() {
+        public FontInfo createFromParcel(Parcel in) {
+            return new FontInfo(in);
+        }
+
+        public FontInfo[] newArray(int size) {
+            return new FontInfo[size];
+        }
+    };
+
+    public FontInfo() {
+    }
+
+    public FontInfo(String packageName, String fontName, String previewPath) {
+        this.packageName = packageName;
+        this.fontName = fontName;
+        this.previewPath = previewPath;
+    }
+
+    public FontInfo(FontInfo from) {
+        this.packageName = from.packageName;
+        this.fontName = from.fontName;
+        this.previewPath = from.previewPath;
+    }
+
+    public FontInfo(Parcel in) {
+        this.packageName = in.readString();
+        this.fontName = in.readString();
+        this.previewPath = in.readString();
+    }
+
+    public void updateFrom(FontInfo info) {
+        this.packageName = info.packageName;
+        this.fontName = info.fontName;
+        this.previewPath = info.previewPath;
+    }
+
+    public String toDelimitedString() {
+        return this.packageName + "|"
+                + this.fontName + "|"
+                + this.previewPath;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(this.packageName);
+        dest.writeString(this.fontName);
+        dest.writeString(this.previewPath);
+    }
+
+    @Override
+    public String toString() {
+        return "FontInfo{" +
+                "packageName='" + packageName + '\'' +
+                ", fontName='" + fontName + '\'' +
+                ", previewPath='" + previewPath + '\'' +
+                '}';
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == null)
+            return false;
+        if (!(obj instanceof FontInfo))
+            return false;
+        FontInfo other = (FontInfo) obj;
+        return TextUtils.equals(this.packageName, other.packageName)
+                && TextUtils.equals(this.fontName, other.fontName)
+                && TextUtils.equals(this.previewPath, other.previewPath);
+    }
+
+    @Override
+    public int compareTo(FontInfo o) {
+        int result = this.fontName.toString().compareToIgnoreCase(o.fontName.toString());
+        return result;
+    }
+}
diff --git a/core/java/android/content/IFontService.aidl b/core/java/android/content/IFontService.aidl
new file mode 100644
index 00000000000..13803b019a6
--- /dev/null
+++ b/core/java/android/content/IFontService.aidl
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2018 The Dirty Unicorns Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content;
+
+import android.content.FontInfo;
+
+import java.util.Map;
+
+interface IFontService {
+    /**
+     * Apply a specified font pack
+     * @param info the FontInfo object to apply
+     */
+    void applyFont(in FontInfo info);
+
+    /**
+     * @return current FontInfo
+     */
+    FontInfo getFontInfo();
+
+    /**
+     * @return A Map<String, List<FontInfo>> of all the packages that provides fonts
+     *         mapped to a list of all the fonts that package provides
+     */
+    Map getAllFonts();
+}
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 47cee742c48..f7f442f6e67 100755
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -3981,6 +3981,20 @@ public final class Settings {
          */
         public static final String QS_LAYOUT_ROWS = "qs_layout_rows";
 
+        /**
+         * Hold current font name and name of the originating package Uses "|" as a delimiter
+         *
+         * @hide
+         */
+        public static final String FONT_INFO = "font_info";
+
+        /**
+         * Hold list of installed font provider packages. Uses "|" as a delimiter
+         *
+         * @hide
+         */
+        public static final String FONT_PACKAGES = "font_packages";
+
         /**
          * Settings to backup. This is here so that it's in the same place as the settings
          * keys and easy to update.
@@ -4151,6 +4165,8 @@ public final class Settings {
             PRIVATE_SETTINGS.add(QS_LAYOUT_COLUMNS_LANDSCAPE);
             PRIVATE_SETTINGS.add(QS_TILE_TITLE_VISIBILITY);
             PRIVATE_SETTINGS.add(QS_LAYOUT_ROWS);
+            PRIVATE_SETTINGS.add(FONT_INFO);
+            PRIVATE_SETTINGS.add(FONT_PACKAGES);
         }
 
         /**
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index 9ebd541caaf..864961760c5 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -3557,6 +3557,13 @@
     <permission android:name="android.permission.INSTANT_APP_FOREGROUND_SERVICE"
         android:protectionLevel="signature|development|instant|appop" />
 
+    <!-- Allows an application to access the font manager
+         @hide -->
+    <permission android:name="android.permission.ACCESS_FONT_MANAGER"
+        android:label="@string/permlab_accessFontManager"
+        android:description="@string/permdesc_accessFontManager"
+        android:protectionLevel="signatureOrSystem" />
+
     <application android:process="system"
                  android:persistent="true"
                  android:hasCode="false"
diff --git a/core/res/res/values/custom_arrays.xml b/core/res/res/values/custom_arrays.xml
new file mode 100644
index 00000000000..1ae34f70631
--- /dev/null
+++ b/core/res/res/values/custom_arrays.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+** Not a Contribution.
+**
+** Copyright 2012, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+<resources>
+    <!-- System font packages (overlay in vendor) -->
+    <string-array name="config_fontPackages" translatable="false">
+    </string-array>
+</resources>
diff --git a/core/res/res/values/custom_strings.xml b/core/res/res/values/custom_strings.xml
new file mode 100644
index 00000000000..565745efc26
--- /dev/null
+++ b/core/res/res/values/custom_strings.xml
@@ -0,0 +1,26 @@
+
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* //device/apps/common/assets/res/any/strings.xml
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <!-- [CHAR LIMIT=NONE] Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_accessFontManager">access font manager</string>
+    <!-- [CHAR LIMIT=NONE] Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_accessFontManager">Allows an application to access the font manager.</string>
+</resources>
diff --git a/core/res/res/values/custom_symbols.xml b/core/res/res/values/custom_symbols.xml
new file mode 100644
index 00000000000..26bfc7e6b2f
--- /dev/null
+++ b/core/res/res/values/custom_symbols.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* //device/apps/common/assets/res/any/strings.xml
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+  <!-- System fonts -->
+  <java-symbol type="array" name="config_fontPackages" />
+</resources>
diff --git a/services/core/java/com/android/server/FontService.java b/services/core/java/com/android/server/FontService.java
new file mode 100644
index 00000000000..71e0ea0b8e0
--- /dev/null
+++ b/services/core/java/com/android/server/FontService.java
@@ -0,0 +1,689 @@
+/*
+ * Copyright (C) 2018 The Dirty Unicorns Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import static android.content.Intent.ACTION_PACKAGE_ADDED;
+import static android.content.Intent.ACTION_PACKAGE_CHANGED;
+import static android.content.Intent.ACTION_PACKAGE_REMOVED;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+
+import android.annotation.NonNull;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.IFontService;
+import android.content.FontInfo;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.res.AssetManager;
+import android.graphics.FontListParser;
+import android.graphics.Typeface;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.Environment;
+import android.os.FileUtils;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Process;
+import android.os.SELinux;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.text.FontConfig;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.Slog;
+import android.util.Xml;
+
+public class FontService extends IFontService.Stub {
+    private static final String TAG = "FontService";
+    private static final File SYSTEM_THEME_DIR = new File(Environment.getDataSystemDirectory(),
+            "theme");
+    private static final File SYSTEM_THEME_FONT_DIR = new File(SYSTEM_THEME_DIR, "fonts");
+    private static final File SYSTEM_THEME_CACHE_DIR = new File(SYSTEM_THEME_DIR, "cache");
+    private static final File SYSTEM_THEME_PREVIEW_CACHE_DIR = new File(SYSTEM_THEME_DIR,
+            "font_previews");
+    private static final String FONTS_XML = "fonts.xml";
+    private static final String FONT_IDENTIFIER = "custom_rom_font_provider";
+
+    private Context mContext;
+    private FontHandler mFontHandler;
+    private HandlerThread mFontWorker;
+    private final Map<String, List<FontInfo>> mFontMap = new HashMap<>();
+    private final FontInfo mFontInfo = new FontInfo();
+
+    public static class Lifecycle extends SystemService {
+        FontService mService;
+
+        public Lifecycle(Context context) {
+            super(context);
+        }
+
+        @Override
+        public void onStart() {
+            mService = new FontService(getContext());
+            publishBinderService("dufont", mService);
+        }
+
+        @Override
+        public void onBootPhase(int phase) {
+            if (phase == PHASE_SYSTEM_SERVICES_READY) {
+                if (makeDir(SYSTEM_THEME_DIR)) {
+                    makeDir(SYSTEM_THEME_PREVIEW_CACHE_DIR);
+                    restoreconThemeDir();
+                }
+                mService.sendInitializeFontMapMessage();
+            }
+        }
+    }
+
+    private class FontHandler extends Handler {
+        private static final int MESSAGE_INITIALIZE_MAP = 1;
+        private static final int MESSAGE_CHANGE_FONT = 2;
+        private static final int MESSAGE_PACKAGE_ADDED_OR_UPDATED = 3;
+        private static final int MESSAGE_PACKAGE_REMOVED = 4;
+
+        public FontHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            String packageName;
+            switch (msg.what) {
+                case MESSAGE_INITIALIZE_MAP:
+                    initializeFontMap();
+                    break;
+                case MESSAGE_CHANGE_FONT:
+                    final FontInfo info = (FontInfo) msg.obj;
+                    applyFontsPriv(info);
+                    break;
+                case MESSAGE_PACKAGE_ADDED_OR_UPDATED:
+                    packageName = (String) msg.obj;
+                    boolean isFontProvider = isPackageFontProvider(packageName);
+                    if (isFontProvider) {
+                        Log.e(TAG, packageName + " was added or updated. Adding or updating fonts");
+                        synchronized (mFontMap) {
+                            processFontPackage(packageName);
+                        }
+                    }
+                    break;
+                case MESSAGE_PACKAGE_REMOVED:
+                    packageName = (String) msg.obj;
+                    boolean hadFonts = mFontMap.containsKey(packageName);
+                    if (hadFonts) {
+                        synchronized (mFontMap) {
+                            Log.e(TAG,
+                                    packageName + " was removed. Clearing fonts from provider map");
+                            removeFontPackage(packageName);
+                        }
+                        // if removed package provided current font, reset to system
+                        if (TextUtils.equals(packageName, mFontInfo.packageName)) {
+                            Log.e(TAG, packageName
+                                    + " provided the current font. Restoring to system font");
+                            applyFontsPriv(FontInfo.getDefaultFontInfo());
+                        }
+                    }
+                    break;
+                default:
+                    Log.w(TAG, "Unknown message " + msg.what);
+                    break;
+            }
+        }
+    }
+
+    private class PackageReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(@NonNull
+        final Context context, @NonNull
+        final Intent intent) {
+            final Uri data = intent.getData();
+            if (data == null) {
+                Slog.e(TAG, "Cannot handle package broadcast with null data");
+                return;
+            }
+            final String packageName = data.getSchemeSpecificPart();
+
+            Message msg;
+            switch (intent.getAction()) {
+                case ACTION_PACKAGE_ADDED:
+                case ACTION_PACKAGE_CHANGED:
+                    msg = mFontHandler.obtainMessage(
+                            FontHandler.MESSAGE_PACKAGE_ADDED_OR_UPDATED);
+                    msg.obj = packageName;
+                    mFontHandler.sendMessage(msg);
+                    break;
+                case ACTION_PACKAGE_REMOVED:
+                    msg = mFontHandler.obtainMessage(
+                            FontHandler.MESSAGE_PACKAGE_REMOVED);
+                    msg.obj = packageName;
+                    mFontHandler.sendMessage(msg);
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+
+    public FontService(Context context) {
+        mContext = context;
+        mFontWorker = new HandlerThread("FontServiceWorker", Process.THREAD_PRIORITY_BACKGROUND);
+        mFontWorker.start();
+        mFontHandler = new FontHandler(mFontWorker.getLooper());
+        mFontInfo.updateFrom(getCurrentFontInfoFromProvider());
+        IntentFilter packageFilter = new IntentFilter();
+        packageFilter.addAction(ACTION_PACKAGE_ADDED);
+        packageFilter.addAction(ACTION_PACKAGE_CHANGED);
+        packageFilter.addAction(ACTION_PACKAGE_REMOVED);
+        packageFilter.addDataScheme("package");
+        mContext.registerReceiverAsUser(new PackageReceiver(), UserHandle.ALL,
+                packageFilter, null, null);
+    }
+
+    @Override
+    public void applyFont(FontInfo info) {
+        enforceFontService();
+        if (info.packageName == null
+                || info.fontName == null
+                || info.previewPath == null) {
+            info.updateFrom(FontInfo.getDefaultFontInfo());
+        }
+        Log.e(TAG, "applyFonts() packageName = " + info.toString());
+        Message msg = mFontHandler.obtainMessage(
+                FontHandler.MESSAGE_CHANGE_FONT);
+        msg.obj = info;
+        mFontHandler.sendMessage(msg);
+    }
+
+    @Override
+    public FontInfo getFontInfo() {
+        enforceFontService();
+        FontInfo info = new FontInfo(mFontInfo);
+        return info;
+    }
+
+    @Override
+    public Map<String, List<FontInfo>> getAllFonts() {
+        enforceFontService();
+        return mFontMap;
+    }
+
+    private void sendInitializeFontMapMessage() {
+        Message msg = mFontHandler.obtainMessage(
+                FontHandler.MESSAGE_INITIALIZE_MAP);
+        mFontHandler.sendMessage(msg);
+    }
+
+    private void initializeFontMap() {
+        List<String> packageList = getInstalledFontPackagesFromProvider();
+        for (String pkg : packageList) {
+            processFontPackage(pkg);
+        }
+        Log.e(TAG, " Font map initialized- " + mFontMap.toString());
+    }
+
+    private void processFontPackage(String packageName) {
+        List<FontInfo> infoList = new ArrayList<FontInfo>();
+        Context appContext = getAppContext(packageName);
+        AssetManager am = appContext.getAssets();
+        List<String> fontZips = getFontsFromPackage(packageName);
+        File packageFontPreviewDir = new File(SYSTEM_THEME_PREVIEW_CACHE_DIR, packageName);
+        if (packageFontPreviewDir.exists() && packageFontPreviewDir.isDirectory()) {
+            FileUtils.deleteContentsAndDir(packageFontPreviewDir);
+        }
+        makeDir(packageFontPreviewDir);
+        // iterate list of fonts package provides
+        for (String fontZip : fontZips) {
+            // create preview directory for this font
+            // for now, just delete and do it again
+            // TODO: clean this up
+            String sanitizedZipName = sanitizeZipName(fontZip);
+            File currentFontPreviewDir = new File(packageFontPreviewDir, sanitizedZipName);
+            makeDir(currentFontPreviewDir);
+
+            Log.e(TAG, "CurrentFontPreviewDir absolute path = "
+                    + currentFontPreviewDir.getAbsolutePath());
+
+            // copy zip to preview cache
+            File fontZipFile = new File(currentFontPreviewDir, fontZip);
+            try (InputStream inputStream = am.open("fonts/" + fontZip)) {
+                FileUtils.copyToFileOrThrow(inputStream, fontZipFile);
+            } catch (IOException e) {
+                Log.e(TAG, "There is an exception when trying to copy themed fonts", e);
+            }
+
+            // get fonts.xml from zip
+            File fontXmlFile = new File(currentFontPreviewDir, FONTS_XML);
+            unzipFile(fontZipFile, fontXmlFile, FONTS_XML);
+
+            // parse fonts.xml for name of preview typeface
+            String fontFileName = getPreviewFontNameFromXml(fontXmlFile,
+                    currentFontPreviewDir.getAbsolutePath());
+
+            // extract tff file from zip
+            File fontFile = new File(fontFileName);
+            unzipFile(fontZipFile, fontFile, fontFile.getName());
+
+            // clean up workspace
+            if (fontXmlFile.exists()) {
+                fontXmlFile.delete();
+            }
+            if (fontZipFile.exists()) {
+                fontZipFile.delete();
+            }
+
+            // create FontInfo and add to list
+            FontInfo fontInfo = new FontInfo();
+            fontInfo.fontName = sanitizedZipName;
+            fontInfo.packageName = packageName;
+            fontInfo.previewPath = fontFile.getAbsolutePath();
+            infoList.add(fontInfo);
+        }
+        // add or replace font list
+        if (mFontMap.containsKey(packageName)) {
+            mFontMap.replace(packageName, infoList);
+        } else {
+            mFontMap.put(packageName, infoList);
+        }
+
+        // update package list in provider
+        List<String> packageList = getInstalledFontPackagesFromProvider();
+        if (!packageList.contains(packageName)) {
+            packageList.add(packageName);
+            putFontPackagesIntoProvider(packageList);
+        }
+        Log.e(TAG, "The new FontInfo map: " + mFontMap.toString());
+    }
+
+    private void removeFontPackage(String packageName) {
+        if (!mFontMap.containsKey(packageName)) {
+            return;
+        }
+        File packageFontPreviewDir = new File(SYSTEM_THEME_PREVIEW_CACHE_DIR, packageName);
+        if (packageFontPreviewDir.exists() && packageFontPreviewDir.isDirectory()) {
+            FileUtils.deleteContentsAndDir(packageFontPreviewDir);
+        }
+        mFontMap.remove(packageName, mFontMap.get(packageName));
+
+        // update package list in provider
+        List<String> packageList = getInstalledFontPackagesFromProvider();
+        if (packageList.contains(packageName)) {
+            packageList.remove(packageName);
+            putFontPackagesIntoProvider(packageList);
+        }
+    }
+
+    private static String getPreviewFontNameFromXml(File xmlFile, String path) {
+        FontConfig fontConfig = null;
+        try {
+            fontConfig = FontListParser.parse(xmlFile, path);
+        } catch (Exception e) {
+            Log.e(TAG, "Exception thrown parsing fonts.xml! " + e.toString());
+            return null;
+        }
+        if (fontConfig != null) {
+            List<FontConfig.Family> families = fontConfig.getFamilies();
+            if (families != null) {
+                FontConfig.Family family = families.get(0);
+                if (family != null) {
+                    FontConfig.Font[] fonts = family.getFonts();
+                    if (fonts != null && fonts.length > 0) {
+                        FontConfig.Font font = fonts[0];
+                        if (font != null) {
+                            Log.e(TAG, "Font found from parsing fonts.xml! " + font.getFontName());
+                            return font.getFontName();
+                        }
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    private boolean isPackageFontProvider(String packageName) {
+        Context appContext = getAppContext(packageName);
+        int id = appContext.getResources().getIdentifier(FONT_IDENTIFIER,
+                "bool",
+                appContext.getPackageName());
+        return id != 0;
+    }
+
+    private List<String> getFontsFromPackage(String packageName) {
+        Context appContext = getAppContext(packageName);
+        AssetManager am = appContext.getAssets();
+        List<String> list = new ArrayList<String>();
+        try {
+            list.addAll(Arrays.asList(am.list("fonts")));
+        } catch (Exception e) {
+            Log.e(TAG, appContext.getPackageName() + "did not have a fonts folder!");
+        }
+        Log.e(TAG, packageName + " has the following fonts - " + list.toString());
+        return list;
+    }
+
+    private void putFontPackagesIntoProvider(List<String> packages) {
+        StringBuilder builder = new StringBuilder();
+        for (int i = 0; i < packages.size(); i++) {
+            builder.append(packages.get(i));
+            builder.append("|");
+        }
+        Settings.System.putStringForUser(mContext.getContentResolver(),
+                Settings.System.FONT_PACKAGES,
+                builder.toString(), UserHandle.USER_CURRENT);
+    }
+
+    private List<String> getInstalledFontPackagesFromProvider() {
+        String packages = Settings.System.getStringForUser(mContext.getContentResolver(),
+                Settings.System.FONT_PACKAGES, UserHandle.USER_CURRENT);
+        List<String> packageList = new ArrayList<>();
+        if (TextUtils.isEmpty(packages)) {
+            packageList.addAll(Arrays.asList(mContext.getResources()
+                    .getStringArray(com.android.internal.R.array.config_fontPackages)));
+        } else {
+            packageList.addAll(Arrays.asList(packages.split("\\|")));
+        }
+        return packageList;
+    }
+
+    private void putCurrentFontInfoInProvider(FontInfo fontInfo) {
+        Settings.System.putStringForUser(mContext.getContentResolver(), Settings.System.FONT_INFO,
+                fontInfo.toDelimitedString(), UserHandle.USER_CURRENT);
+    }
+
+    // index 0 is package name, index 1 is font name, index 2 is previewPath
+    private FontInfo getCurrentFontInfoFromProvider() {
+        String info = Settings.System.getStringForUser(mContext.getContentResolver(),
+                Settings.System.FONT_INFO, UserHandle.USER_CURRENT);
+        FontInfo fontInfo = new FontInfo();
+        if (TextUtils.isEmpty(info)) {
+            fontInfo.updateFrom(FontInfo.getDefaultFontInfo());
+        } else {
+            List<String> infoList = Arrays.asList(info.split("\\|"));
+            fontInfo.packageName = infoList.get(0);
+            fontInfo.fontName = infoList.get(1);
+            fontInfo.previewPath = infoList.get(2);
+        }
+        return fontInfo;
+    }
+
+    private Context getAppContext(String packageName) {
+        Context ctx = null;
+        try {
+            ctx = mContext.createPackageContext(packageName,
+                    Context.CONTEXT_IGNORE_SECURITY);
+        } catch (NameNotFoundException e) {
+            Log.e(TAG, "Failed to get " + packageName + " context");
+        }
+        return ctx;
+    }
+
+    private void applyFontsPriv(FontInfo info) {
+        Log.e(TAG, "applyFontsPriv() packageName = " + info.toString());
+        final long ident = Binder.clearCallingIdentity();
+        try {
+            if (info.equals(FontInfo.getDefaultFontInfo())) {
+                clearFonts();
+            } else {
+                copyFonts(info);
+            }
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    private void copyFonts(FontInfo info) {
+        // Prepare local cache dir for font package assembly
+
+        File cacheDir = new File(SYSTEM_THEME_CACHE_DIR, "FontCache");
+        if (cacheDir.exists()) {
+            FileUtils.deleteContentsAndDir(cacheDir);
+        }
+
+        boolean created = cacheDir.mkdirs();
+        if (!created) {
+            Log.e(TAG, "Could not create cache directory...");
+        }
+
+        // Copy system fonts into our cache dir
+        copyDir("/system/fonts", cacheDir.getAbsolutePath());
+
+        // Append zip to filename since it is probably removed
+        // for list presentation
+        String zipFileName = info.fontName;
+        if (!zipFileName.endsWith(".zip")) {
+            zipFileName = zipFileName + ".zip";
+        }
+
+        // Copy target themed fonts zip to our cache dir
+        Context themeContext = getAppContext(info.packageName);
+        AssetManager am = themeContext.getAssets();
+        File fontZip = new File(cacheDir, zipFileName);
+        try (InputStream inputStream = am.open("fonts/" + zipFileName)) {
+            FileUtils.copyToFileOrThrow(inputStream, fontZip);
+        } catch (IOException e) {
+            Log.e(TAG, "There is an exception when trying to copy themed fonts", e);
+        }
+
+        // Unzip new fonts and delete zip file, overwriting any system fonts
+        unzip(fontZip.getAbsolutePath(), cacheDir.getAbsolutePath());
+
+        boolean deleted = fontZip.delete();
+        if (!deleted) {
+            Log.e(TAG, "Could not delete ZIP file");
+        }
+
+        // Check if theme zip included a fonts.xml. If not, get from existing file in /system
+        File srcConfig = new File("/system/etc/fonts.xml");
+        File dstConfig = new File(cacheDir, "fonts.xml");
+        if (!dstConfig.exists()) {
+            try {
+                FileUtils.copyFileOrThrow(srcConfig, dstConfig);
+            } catch (IOException e) {
+                Log.e(TAG, "There is an exception when trying to copy themed fonts", e);
+            }
+        }
+
+        // Prepare system theme fonts folder and copy new fonts folder from our cache
+        FileUtils.deleteContentsAndDir(SYSTEM_THEME_FONT_DIR);
+        makeDir(SYSTEM_THEME_FONT_DIR);
+        copyDir(cacheDir.getAbsolutePath(), SYSTEM_THEME_FONT_DIR.getAbsolutePath());
+
+        // Let system know it's time for a font change
+        FileUtils.deleteContentsAndDir(cacheDir);
+        refreshFonts();
+        mFontInfo.updateFrom(info);
+        putCurrentFontInfoInProvider(mFontInfo);
+    }
+
+    private static String sanitizeZipName(String zipFile) {
+        return zipFile.substring(0, zipFile.length() - 4);
+    }
+
+    private void refreshFonts() {
+        // Set permissions on font files and config xml
+        if (SYSTEM_THEME_FONT_DIR.exists()) {
+            // Set permissions
+            setPermissionsRecursive(SYSTEM_THEME_FONT_DIR,
+                    FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IRWXO,
+                    FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IROTH | FileUtils.S_IXOTH);
+            restoreconThemeDir();
+        }
+        // Notify zygote that themes need a refresh
+        SystemProperties.set("sys.refresh_theme", "1");
+        float fontSize = Settings.System.getFloatForUser(mContext.getContentResolver(),
+                Settings.System.FONT_SCALE, 1.0f, UserHandle.USER_CURRENT);
+        Settings.System.putFloatForUser(mContext.getContentResolver(),
+                Settings.System.FONT_SCALE, (fontSize + 0.0000001f), UserHandle.USER_CURRENT);
+    }
+
+    private void clearFonts() {
+        FileUtils.deleteContentsAndDir(SYSTEM_THEME_FONT_DIR);
+        refreshFonts();
+        mFontInfo.updateFrom(FontInfo.getDefaultFontInfo());
+        putCurrentFontInfoInProvider(mFontInfo);
+    }
+
+    private void enforceFontService() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_FONT_MANAGER,
+                "FontService");
+    }
+
+    private static void setPermissions(File path, int permissions) {
+        FileUtils.setPermissions(path, permissions, -1, -1);
+    }
+
+    private static void setPermissionsRecursive(File dir, int file, int folder) {
+        if (!dir.isDirectory()) {
+            setPermissions(dir, file);
+            return;
+        }
+
+        for (File child : dir.listFiles()) {
+            if (child.isDirectory()) {
+                setPermissionsRecursive(child, file, folder);
+                setPermissions(child, folder);
+            } else {
+                setPermissions(child, file);
+            }
+        }
+
+        setPermissions(dir, folder);
+    }
+
+    private static boolean restoreconThemeDir() {
+        return SELinux.restoreconRecursive(SYSTEM_THEME_DIR);
+    }
+
+    private static boolean makeDir(File dir) {
+        if (dir.exists()) {
+            return dir.isDirectory();
+        }
+        if (dir.mkdirs()) {
+            int permissions = FileUtils.S_IRWXU | FileUtils.S_IRWXG |
+                    FileUtils.S_IRWXO;
+            SELinux.restorecon(dir);
+            return FileUtils.setPermissions(dir, permissions, -1, -1) == 0;
+        }
+        return false;
+    }
+
+    private static boolean copyDir(String src, String dst) {
+        File[] files = new File(src).listFiles();
+        boolean success = true;
+
+        if (files != null) {
+            for (File file : files) {
+                File newFile = new File(dst + File.separator +
+                        file.getName());
+                if (file.isDirectory()) {
+                    success &= copyDir(file.getAbsolutePath(),
+                            newFile.getAbsolutePath());
+                } else {
+                    success &= FileUtils.copyFile(file, newFile);
+                }
+            }
+        } else {
+            // not a directory
+            success = false;
+        }
+        return success;
+    }
+
+    private static void unzipFile(File zipFile, File destFile, String fileName) {
+        try {
+            ZipInputStream zis = new ZipInputStream(
+                    new BufferedInputStream(new FileInputStream(zipFile)));
+            ZipEntry ze;
+            int count;
+            byte[] buffer = new byte[8192];
+            boolean isDone = false;
+            while (!isDone && (ze = zis.getNextEntry()) != null) {
+                if (ze.isDirectory() || !ze.getName().equals(fileName)) {
+                    continue;
+                }
+                if (ze.getName().equals(fileName)) {
+                    Log.e(TAG, "iterating " + zipFile.getName() + "Found " + fileName
+                            + ", trying to extract");
+                    FileOutputStream fout = new FileOutputStream(destFile);
+                    try {
+                        while ((count = zis.read(buffer)) != -1)
+                            fout.write(buffer, 0, count);
+                    } finally {
+                        fout.close();
+                    }
+                    isDone = true;
+                }
+            }
+            zis.close();
+        } catch (IOException e) {
+            Log.e(TAG, "There is an exception when trying to unzip", e);
+        }
+    }
+
+    private static void unzip(String source, String destination) {
+        try (ZipInputStream inputStream = new ZipInputStream(
+                new BufferedInputStream(new FileInputStream(source)))) {
+            ZipEntry zipEntry;
+            int count;
+            byte[] buffer = new byte[8192];
+
+            while ((zipEntry = inputStream.getNextEntry()) != null) {
+                File file = new File(destination, zipEntry.getName());
+                File dir = zipEntry.isDirectory() ? file : file.getParentFile();
+
+                if (!dir.isDirectory() && !dir.mkdirs()) {
+                    throw new FileNotFoundException("Failed to ensure directory: " +
+                            dir.getAbsolutePath());
+                }
+
+                if (zipEntry.isDirectory()) {
+                    continue;
+                }
+
+                try (FileOutputStream outputStream = new FileOutputStream(file)) {
+                    while ((count = inputStream.read(buffer)) != -1) {
+                        outputStream.write(buffer, 0, count);
+                    }
+                }
+            }
+        } catch (IOException e) {
+            Log.e(TAG, "There is an exception when trying to unzip", e);
+        }
+    }
+}
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 66a723ea8f0..ab46dc8cdf8 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -211,6 +211,8 @@ public final class SystemServer {
             "com.android.server.autofill.AutofillManagerService";
     private static final String TIME_ZONE_RULES_MANAGER_SERVICE_CLASS =
             "com.android.server.timezone.RulesManagerService$Lifecycle";
+    private static final String FONT_SERVICE_CLASS =
+            "com.android.server.FontService$Lifecycle";
 
     private static final String PERSISTENT_DATA_BLOCK_PROP = "ro.frp.pst";
 
@@ -652,6 +654,11 @@ public final class SystemServer {
         mSystemServiceManager.startService(new OverlayManagerService(mSystemContext, installer));
         traceEnd();
 
+        // Manages fonts
+        traceBeginAndSlog("StartFontService");
+        mSystemServiceManager.startService(FONT_SERVICE_CLASS);
+        traceEnd();
+
         // The sensor service needs access to package manager service, app ops
         // service, and permissions service, therefore we start it after them.
         // Start sensor service in a separate thread. Completion should be checked
-- 
2.20.1

